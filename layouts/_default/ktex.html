<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>TEX â†” PNG å·¥å…·</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; padding: 2em; }
    .card { background: white; padding: 2em; border-radius: 10px; box-shadow: 0 0 10px #ccc; max-width: 600px; margin: auto; }
    h2 { margin-bottom: 1em; }
    input[type="file"] { margin: 1em 0; }
    button { margin-right: 1em; padding: 0.6em 1.2em; }
    #log { margin-top: 1em; white-space: pre-wrap; background: #eee; padding: 1em; border-radius: 8px; max-height: 300px; overflow: auto; }
  </style>
</head>
<body>
<div class="card">
  <h2>ðŸŽ® TEX â†” PNG å·¥å…·</h2>
  <input type="file" id="fileInput" multiple accept=".tex">
  <br>
  <button onclick="handleTexToPng()">TEX â†’ PNG</button>
  <button onclick="handlePngToTex()">PNG â†’ TEX</button>
  <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
  <div id="log">å‡†å¤‡å°±ç»ªã€‚</div>
</div>
<canvas id="canvas" style="display:none;"></canvas>

<script>
// å·¥å…·å‡½æ•°
function log(msg) {
  document.getElementById('log').textContent += "\n" + msg;
}
function clearLog() {
  document.getElementById('log').textContent = "å‡†å¤‡å°±ç»ªã€‚";
}
function saveFile(filename, blob) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

// ä¸»å¤„ç†ï¼šTEX â†’ PNG
async function handleTexToPng() {
  const files = document.getElementById('fileInput').files;
  if (!files.length) return alert("è¯·å…ˆé€‰æ‹©æ–‡ä»¶");

  for (const file of files) {
    if (file.name.endsWith('.zip')) {
      await unzipAndProcess(file, handleTexToPngFile);
    } else if (file.name.endsWith('.tex')) {
      await handleTexToPngFile(file);
    } else {
      log(`è·³è¿‡éž tex æ–‡ä»¶ï¼š${file.name}`);
    }
  }
}

async function handleTexToPngFile(file) {
  const buf = await file.arrayBuffer();
  const view = new DataView(buf);

  if (String.fromCharCode(...new Uint8Array(buf.slice(0, 4))) !== 'KTEX') {
    log(`âŒ æ— æ•ˆ TEX æ–‡ä»¶ï¼š${file.name}`);
    return;
  }

  const header = view.getUint32(4, true);
  const numMips = (header >> 13) & 31;
  const format = (header >> 4) & 31;
  if (format !== 4) {
    log(`âš ï¸ ä»…æ”¯æŒ ARGB æ ¼å¼ï¼Œ${file.name} çš„æ ¼å¼ä¸º ${format}`);
    return;
  }

  let offset = 8;
  const width = view.getUint16(offset, true); offset += 2;
  const height = view.getUint16(offset, true); offset += 2;
  offset += 2; // pitch
  const dataSize = view.getUint32(offset, true); offset += 4;

  offset = 8 + numMips * 10;
  const data = new Uint8ClampedArray(buf.slice(offset, offset + dataSize));

  const canvas = document.getElementById('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(width, height);
  imageData.data.set(data);
  ctx.putImageData(imageData, 0, 0);

  const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
  saveFile(file.name.replace(/\.tex$/i, '.png'), blob);
  log(`âœ… ${file.name} â†’ PNG`);
}

// ä¸»å¤„ç†ï¼šPNG â†’ TEX
async function handlePngToTex() {
  const files = document.getElementById('fileInput').files;
  if (!files.length) return alert("è¯·å…ˆé€‰æ‹©æ–‡ä»¶");

  for (const file of files) {
    if (file.name.endsWith('.zip')) {
      await unzipAndProcess(file, handlePngToTexFile);
    } else if (file.name.endsWith('.png')) {
      await handlePngToTexFile(file);
    } else {
      log(`è·³è¿‡éž png æ–‡ä»¶ï¼š${file.name}`);
    }
  }
}

async function handlePngToTexFile(file) {
  const img = new Image();
  const blobURL = URL.createObjectURL(file);
  img.src = blobURL;

  await new Promise(resolve => img.onload = resolve);
  const canvas = document.getElementById('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, img.width, img.height);
  const rgba = imageData.data;

  // ç”Ÿæˆ TEX æ•°æ®
  const mipHeader = new ArrayBuffer(10);
  const mipView = new DataView(mipHeader);
  mipView.setUint16(0, img.width, true);
  mipView.setUint16(2, img.height, true);
  mipView.setUint16(4, 0, true); // pitch
  mipView.setUint32(6, rgba.length, true);

  // å†™ TEX header
  const texHeader = new Uint8Array(8);
  texHeader.set([...'KTEX'].map(c => c.charCodeAt(0)), 0);
  let header = 0;
  header |= 0; // platform = 0
  header |= (4 << 4); // ARGB
  header |= (2 << 9); // 2D
  header |= (1 << 13); // 1 mip
  header |= (0 << 18); // flags
  header |= (0 << 20); // remainder
  const headerView = new DataView(texHeader.buffer);
  headerView.setUint32(4, header, true);

  const texBlob = new Blob([
    texHeader,
    mipHeader,
    new Uint8Array(rgba.buffer)
  ]);
  saveFile(file.name.replace(/\.png$/i, '.tex'), texBlob);
  log(`âœ… ${file.name} â†’ TEX`);
}

// å¤„ç† ZIP ä¸Šä¼ 
async function unzipAndProcess(file, callback) {
  const zip = await JSZip.loadAsync(file);
  for (const [filename, entry] of Object.entries(zip.files)) {
    if (entry.dir) continue;
    const ext = filename.toLowerCase().split('.').pop();
    if (!['tex', 'png'].includes(ext)) continue;
    const blob = await entry.async('blob');
    blob.name = filename;
    await callback(blob);
  }
}

// åŠ è½½ JSZipï¼ˆç”¨äºŽ ZIP è§£åŽ‹ï¼‰
const script = document.createElement('script');
script.src = "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js";
document.head.appendChild(script);
</script>
</body>
</html>