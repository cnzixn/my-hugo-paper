<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>大 ZIP 流式追加（模组/测试.txt）</title>
<style>
  body{font-family:system-ui,Arial;max-width:920px;margin:24px auto;padding:12px;color:#0b1220}
  h1{font-size:20px;margin:.2rem 0}
  .card{padding:14px;border-radius:12px;background:#fff;border:1px solid #e6eef8;box-shadow:0 6px 18px rgba(20,30,60,.04)}
  .row{display:flex;gap:8px;align-items:center}
  input[type=file]{padding:6px}
  button{padding:8px 12px;border-radius:10px;border:0;background:#1366d6;color:#fff;cursor:pointer}
  button.ghost{background:#6b7280}
  .bar{height:14px;background:#eef2ff;border-radius:999px;overflow:hidden;margin-top:8px}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#60a5fa,#2563eb);transition:width .12s linear}
  pre.log{background:#0b1020;color:#cfe8ff;padding:10px;border-radius:10px;height:200px;overflow:auto;font-size:13px}
  .muted{color:#6b7280;font-size:13px}
  .warn{color:#b45309}
  .err{color:#dc2626'}
  label{font-weight:600}
  input[type=text],textarea{width:100%;padding:8px;border-radius:8px;border:1px solid #e6eef8}
</style>
</head>
<body>
  <h1>大 ZIP 流式追加：向 <code>模组/测试.txt</code> 添加文件（带进度）</h1>
  <div class="card">
    <div class="row">
      <label>源 ZIP（本地）：</label>
      <input id="zipfile" type="file" accept=".zip,application/zip" />
      <button id="startBtn">开始处理</button>
      <button id="abortBtn" class="ghost">中止</button>
    </div>

    <div style="margin-top:10px">
      <label>要写入的路径（可改）：</label>
      <input id="targetPath" type="text" value="模组/测试.txt" />
    </div>
    <div style="margin-top:8px">
      <label>测试文件内容：</label>
      <textarea id="content" rows="4">这是浏览器追加的测试文件。
时间：${new Date().toISOString()}</textarea>
    </div>

    <div style="margin-top:12px">
      <div class="bar"><span id="pbar"></span></div>
      <div class="row" style="justify-content:space-between;margin-top:6px">
        <div class="muted"><span id="pct">0%</span> · 已处理 <span id="processed">0</span> / <span id="totalEntries">0</span> 项</div>
        <div class="muted">速度 <span id="speed">0</span> · 用时 <span id="elapsed">0</span>s</div>
      </div>
      <div class="muted" style="margin-top:6px">当前：<span id="currFile">无</span></div>
    </div>

    <h3 style="margin-top:12px">日志</h3>
    <pre class="log" id="log"></pre>

    <p class="muted" style="margin-top:8px">
      说明：如果你的浏览器支持 <b>File System Access API</b>（Chrome / Edge），程序会流式写入磁盘，不占内存。若不支持将回退为内存 Blob 写入（风险：大文件会耗尽内存并失败）。推荐使用最新的 Chrome / Edge。
    </p>
  </div>

<script type="module">
(async () => {
  const $ = id => document.getElementById(id);
  const logEl = $('log');
  const startBtn = $('startBtn');
  const abortBtn = $('abortBtn');
  const zipFileInput = $('zipfile');
  const pbar = $('pbar');
  const pct = $('pct');
  const processedEl = $('processed');
  const totalEntriesEl = $('totalEntries');
  const currFileEl = $('currFile');
  const speedEl = $('speed');
  const elapsedEl = $('elapsed');

  function log(msg, cls){
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.textContent += line + '\\n';
    logEl.scrollTop = logEl.scrollHeight;
    if (cls === 'err') console.error(line); else console.log(line);
  }

  // 动态导入 zip.js ESM，并做兼容性检查（若页面已加载 window.zip 则可用）
  let zipmod = null;
  try {
    zipmod = await import('https://cdn.jsdelivr.net/npm/@zip.js/zip.js@2.7.41/dist/zip.min.mjs');
    log('已动态导入 zip.js（ESM）');
  } catch (e) {
    log('无法用 ESM 导入 zip.js：' + e.message + '，尝试全局 window.zip（若页面加载了 UMD 版）', 'warn');
    zipmod = window.zip ? window.zip : null;
  }
  if (!zipmod) {
    log('无法加载 zip.js，页面无法继续。请使用能联网的环境或把 zip.js 引入页面。', 'err');
    startBtn.disabled = true;
    return;
  }

  // 获取类/构造器的 helper（兼容命名导出或 default 导出或 window.zip）
  function get(name){
    if (!zipmod) return undefined;
    return zipmod[name] || (zipmod.default && zipmod.default[name]) || (window.zip && window.zip[name]);
  }

  const ZipReader = get('ZipReader');
  const ZipWriter = get('ZipWriter');
  const BlobReader = get('BlobReader');
  const BlobWriter = get('BlobWriter');
  const TextReader = get('TextReader');
  const ReadableStreamWriter = get('ReadableStreamWriter');
  const ReadableStreamReader = get('ReadableStreamReader');
  const WritableStreamWriter = get('WritableStreamWriter');
  const FileSystemWriter = get('FileSystemWriter');

  // 必要 API 检查（我们将尽量使用 Readable/Write stream 接口）
  if (!ZipReader || !ZipWriter || !BlobReader || !(ReadableStreamWriter || BlobWriter)) {
    log('zip.js API 不完整（缺少 ZipReader/ZipWriter/BlobReader/ReadableStream 支持）。请使用 zip.js 的 ESM 版本。', 'err');
    startBtn.disabled = true;
    return;
  }

  let abortController = null;

  function resetProgress(){
    pbar.style.width = '0%';
    pct.textContent = '0%';
    processedEl.textContent = '0';
    totalEntriesEl.textContent = '0';
    currFileEl.textContent = '无';
    speedEl.textContent = '0';
    elapsedEl.textContent = '0';
  }

  function formatBytes(b){
    if (!b) return '0 B';
    const u=['B','KB','MB','GB','TB']; let i=0;
    while(b>=1024 && i<u.length-1){ b/=1024; i++; }
    return b.toFixed(i?2:0) + ' ' + u[i];
  }

  startBtn.addEventListener('click', async () => {
    const file = zipFileInput.files[0];
    if (!file) { alert('请选择源 ZIP 文件'); return; }

    // 防护：如果浏览器不支持 FS API 且文件很大，提醒用户风险
    const hasFS = !!window.showSaveFilePicker;
    if (!hasFS && file.size > 2_000_000_000) { // >~2GB
      if (!confirm('当前浏览器不支持 File System Access API。回退到内存 Blob 写出会占用大量内存，可能导致浏览器崩溃。是否继续？')) return;
    }

    startBtn.disabled = true;
    resetProgress();
    log(`打开源 ZIP： ${file.name} 大小 ${formatBytes(file.size)}`);

    abortController = new AbortController();
    const signal = abortController.signal;

    // 创建 ZipReader（基于 BlobReader）
    let zipReader;
    try {
      zipReader = new ZipReader(new BlobReader(file), { useWebWorkers: true });
    } catch (e) {
      log('创建 ZipReader 失败：' + e.message, 'err');
      startBtn.disabled = false;
      return;
    }

    let entries;
    try {
      entries = await zipReader.getEntries();
      log(`条目数量：${entries.length}`);
      totalEntriesEl.textContent = entries.length;
    } catch (e) {
      log('读取条目失败：' + e.message, 'err');
      startBtn.disabled = false;
      await zipReader.close().catch(()=>{});
      return;
    }

    // 估算总压缩字节（用于进度条：如果没有可用则以文件大小为准）
    let totalCompressed = entries.reduce((s,e)=> s + (e.compressedSize || 0), 0) || file.size;
    const targetPath = (document.getElementById('targetPath').value || '模组/测试.txt').replace(/^\\/+|\\/+$/g,'');
    const contentStr = document.getElementById('content').value || '测试';
    const encoder = new TextEncoder();
    const addBytes = encoder.encode(contentStr).byteLength;

    // 准备输出 writer
    let useFS = false;
    let zipWriter, outWritableHandle, outWritableStream;
    try {
      if (window.showSaveFilePicker && (WritableStreamWriter || FileSystemWriter)) {
        // 推荐走 File System Access API + zip's WritableStreamWriter / FileSystemWriter
        try {
          outWritableHandle = await window.showSaveFilePicker({ suggestedName: file.name.replace(/\\.zip$/i,'') + '.patched.zip', types:[{description:'ZIP',accept:{'application/zip':['.zip']}}] });
          outWritableStream = await outWritableHandle.createWritable();
          // 若 zip.js 提供 FileSystemWriter，优先用；否则用 WritableStreamWriter 包装下
          if (FileSystemWriter) {
            zipWriter = new ZipWriter(new FileSystemWriter(outWritableStream), { zip64: true });
          } else if (WritableStreamWriter) {
            zipWriter = new ZipWriter(new WritableStreamWriter(outWritableStream), { zip64: true });
          } else {
            // fallback: try wrapping directly (may work on some builds)
            zipWriter = new ZipWriter(new WritableStreamWriter(outWritableStream), { zip64: true });
          }
          useFS = true;
          log('已打开磁盘写入（File System Access）');
        } catch (e) {
          log('打开保存文件失败或被拒绝：' + e.message + '，将回退为 Blob 写出', 'warn');
        }
      }
    } catch(e){
      log('尝试 File System API 时出错：' + e.message, 'warn');
    }

    let toBlob = false;
    let blobWriter;
    if (!useFS) {
      // 回退：BlobWriter（内存），提醒用户
      toBlob = true;
      try {
        blobWriter = new BlobWriter('application/zip');
        zipWriter = new ZipWriter(blobWriter, { zip64: true });
        log('使用内存 Blob 写入（可能会占用大量内存）', 'warn');
      } catch (e) {
        log('创建 BlobWriter 失败：' + e.message, 'err');
        startBtn.disabled = false;
        await zipReader.close().catch(()=>{});
        return;
      }
    }

    // 开始逐条复制（流式）
    let processedCompressed = 0;
    const startTime = performance.now();
    let lastTick = startTime;
    let lastProcessed = 0;

    try {
      let idx = 0;
      for (const entry of entries) {
        if (signal.aborted) throw new Error('abort');

        idx++;
        currFileEl.textContent = entry.filename;
        log(`复制 [${idx}/${entries.length}] ${entry.filename}`);

        // 如果源 ZIP 已存在同名目标，跳过（稍后我们会写入新的文件覆盖）
        if (entry.filename === targetPath) {
          log('发现同名目标文件，跳过原始版本（将被新文件替换）', 'muted');
          // update "processed" counters by compressed size if available
          processedCompressed += (entry.compressedSize || 0);
          processedEl.textContent = idx;
          const pctv = Math.min(0.99, (processedCompressed / (totalCompressed + addBytes)));
          pbar.style.width = (pctv * 100).toFixed(2) + '%';
          pct.textContent = (pctv*100).toFixed(2) + '%';
          continue;
        }

        // 获取条目的可读流（ReadableStream），不把整个文件载入内存
        // entry.getData(new ReadableStreamWriter()) 在 zip.js 中会返回一个 ReadableStream
        let rs;
        if (ReadableStreamWriter) {
          rs = await entry.getData(new ReadableStreamWriter({
            onprogress: (loaded, total) => {
              // 这里的 loaded/total 是条目级别；我们用已复制压缩字节 + 本条目进度作为总体进度近似
              const entryCompressed = entry.compressedSize || (total || 0);
              const current = processedCompressed + (entryCompressed ? (loaded / total) * entryCompressed : loaded);
              const pctv = Math.min(0.99, current / (totalCompressed + addBytes));
              pbar.style.width = (pctv * 100).toFixed(2) + '%';
              pct.textContent = (pctv*100).toFixed(2) + '%';
            }
          }));
        } else {
          // 若没有 ReadableStreamWriter，尝试先得 blob（会占内存，尽量少用）
          log('当前 zip.js 不支持 ReadableStreamWriter，条目将以 Blob 形式处理（可能导致内存峰值）', 'warn');
          const b = await entry.getData(new BlobWriter());
          rs = b.stream();
        }

        // 把可读流包装成 zip.js 能接收的 reader 然后写入输出 zip（流式写入）
        if (ReadableStreamReader) {
          await zipWriter.add(entry.filename, new ReadableStreamReader(rs), { lastModDate: entry.lastModDate || new Date() });
        } else {
          // fallback：把流转为 Blob 再写（内存代价）
          const tmpBlob = await new Response(rs).blob();
          await zipWriter.add(entry.filename, new BlobReader(tmpBlob), { lastModDate: entry.lastModDate || new Date() });
        }

        // 更新计数（尽量用 compressedSize 来估算）
        processedCompressed += (entry.compressedSize || 0);
        processedEl.textContent = idx;
        const pctv = Math.min(0.99, processedCompressed / (totalCompressed + addBytes));
        pbar.style.width = (pctv * 100).toFixed(2) + '%';
        pct.textContent = (pctv*100).toFixed(2) + '%';

        // 速度计算
        const now = performance.now();
        if (now - lastTick >= 700) {
          const delta = processedCompressed - lastProcessed;
          const speed = delta / ((now - lastTick)/1000); // bytes/s
          speedEl.textContent = formatBytes(speed) + '/s';
          lastTick = now; lastProcessed = processedCompressed;
          elapsedEl.textContent = ((now - startTime)/1000).toFixed(1);
        }
      }

      // 写入新增文件（文本）
      currFileEl.textContent = targetPath;
      log('写入新增文件：' + targetPath);
      await zipWriter.add(targetPath, new TextReader(contentStr), { lastModDate: new Date() });
      processedEl.textContent = entries.length + 1;
      processedCompressed += addBytes;
      pbar.style.width = '99%';
      pct.textContent = '99%';

      // 关闭 writer。对于 BlobWriter，close() 返回 Blob；对于 WritableStreamWriter/FileSystemWriter 可能返回 undefined
      log('正在关闭输出 ZIP …');
      const maybeBlob = await zipWriter.close();

      if (useFS) {
        // 如果我们用的是文件系统写流，需要关闭底层流
        if (outWritableStream && typeof outWritableStream.close === 'function') {
          await outWritableStream.close();
        }
        log('已保存到磁盘（你选择的位置）', 'ok');
      } else {
        // Blob 下载
        const blob = maybeBlob || await blobWriter.getData();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = file.name.replace(/\\.zip$/i,'') + '.patched.zip';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
        log('已生成下载（Blob）', 'ok');
      }

      await zipReader.close();
      pbar.style.width = '100%';
      pct.textContent = '100%';
      currFileEl.textContent = '完成';
      elapsedEl.textContent = ((performance.now() - startTime)/1000).toFixed(1);

      log('全部完成 ✅');
    } catch (e) {
      if (e && e.name === 'AbortError') {
        log('操作已中止', 'warn');
      } else {
        log('处理失败：' + (e && e.message ? e.message : e), 'err');
        console.error(e);
      }
      try { await zipReader.close(); } catch(_) {}
      // 若使用 FS，并且 outWritableStream 仍开着，尝试关闭以释放资源
      try { if (outWritableStream && typeof outWritableStream.close === 'function') await outWritableStream.close(); } catch(_) {}
    } finally {
      startBtn.disabled = false;
      abortController = null;
    }
  });

  abortBtn.addEventListener('click', () => {
    if (abortController) {
      abortController.abort();
      log('用户请求中止……');
    } else {
      log('当前没有运行的任务');
    }
  });
})();
</script>
</body>
</html>